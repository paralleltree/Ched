using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

using ConcurrentPriorityQueue;
using Ched.Core;
using Ched.Core.Notes;
using Ched.Core.Events;
using Ched.Localization;

namespace Ched.Components.Exporter
{
    public class SusExporter : IExtendedExpoerter<SusArgs>
    {
        public string FormatName => "Sliding Universal Score(sus形式)";

        public SusArgs CustomArgs { get; set; }

        public void Export(string path, ScoreBook book)
        {
            SusArgs args = CustomArgs;
            var notes = book.Score.Notes;
            using (var writer = new StreamWriter(path))
            {
                writer.WriteLine("This file was generated by Ched {0}.", System.Reflection.Assembly.GetEntryAssembly().GetName().Version.ToString());

                writer.WriteLine("#TITLE \"{0}\"", book.Title);
                writer.WriteLine("#ARTIST \"{0}\"", book.ArtistName);
                writer.WriteLine("#DESIGNER \"{0}\"", book.NotesDesignerName);
                writer.WriteLine("#DIFFICULTY {0}", (int)args.PlayDifficulty + (string.IsNullOrEmpty(args.ExtendedDifficulty) ? "" : ":" + args.ExtendedDifficulty));
                writer.WriteLine("#PLAYLEVEL {0}", args.PlayLevel);
                writer.WriteLine("#SONGID \"{0}\"", args.SongId);
                writer.WriteLine("#WAVE \"{0}\"", args.SoundFileName);
                writer.WriteLine("#WAVEOFFSET {0}", args.SoundOffset);
                writer.WriteLine("#JACKET \"{0}\"", args.JacketFilePath);

                writer.WriteLine();

                writer.WriteLine(args.AdditionalData);

                writer.WriteLine();

                writer.WriteLine("#REQUEST \"ticks_per_beat {0}\"", book.Score.TicksPerBeat);

                writer.WriteLine();

                int barTick = book.Score.TicksPerBeat * 4;
                BarIndexCalculator barIndexCalculator = null;
                try
                {
                    barIndexCalculator = new BarIndexCalculator(book.Score.TicksPerBeat, book.Score.Events.TimeSignatureChangeEvents);
                }
                catch (InvalidTimeSignatureException ex)
                {
                    int beatAt = ex.Tick / book.Score.TicksPerBeat + 1;
                    MessageBox.Show(string.Format(ErrorStrings.InvalidTimeSignature, beatAt), Program.ApplicationName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                foreach (var item in barIndexCalculator.TimeSignatures)
                {
                    writer.WriteLine("#{0:000}02: {1}", item.StartBarIndex, 4f * item.TimeSignature.Numerator / item.TimeSignature.Denominator);
                }

                writer.WriteLine();

                var bpmlist = book.Score.Events.BPMChangeEvents
                    .GroupBy(p => p.BPM)
                    .SelectMany((p, i) => p.Select(q => new { Index = i, Value = q, BarPosition = barIndexCalculator.GetBarPositionFromTick(q.Tick) }))
                    .ToList();

                if (bpmlist.Count >= 36 * 36) throw new ArgumentException("BPM定義数が上限を超えました。");

                var bpmIdentifiers = EnumerateIdentifiers(2).Skip(1).Take(bpmlist.Count).ToList();
                foreach (var item in bpmlist.GroupBy(p => p.Index).Select(p => p.First()))
                {
                    writer.WriteLine("#BPM{0}: {1}", bpmIdentifiers[item.Index], item.Value.BPM);
                }

                foreach (var eventInBar in bpmlist.GroupBy(p => p.BarPosition.BarIndex))
                {
                    var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(eventInBar.Key);
                    int barLength = barTick * sig.Numerator / sig.Denominator;
                    var items = eventInBar.Select(p => (p.BarPosition.TickOffset, bpmIdentifiers[p.Index]));
                    writer.WriteLine("#{0:000}08: {1}", eventInBar.Key, GenerateLineData(barLength, items));
                }

                writer.WriteLine();
                var speeds = book.Score.Events.HighSpeedChangeEvents.Select(p =>
                {
                    var barPos = barIndexCalculator.GetBarPositionFromTick(p.Tick);
                    return string.Format("{0}'{1}:{2}", barPos.BarIndex, barPos.TickOffset, p.SpeedRatio);
                });
                writer.WriteLine("#TIL00: \"{0}\"", string.Join(", ", speeds));
                writer.WriteLine("#HISPEED 00");
                writer.WriteLine("#MEASUREHS 00");

                writer.WriteLine();

                var shortNotes = notes.Taps.Cast<TappableBase>().Select(p => new { Type = '1', Note = p })
                    .Concat(notes.ExTaps.Cast<TappableBase>().Select(p => new { Type = '2', Note = p }))
                    .Concat(notes.Flicks.Cast<TappableBase>().Select(p => new { Type = '3', Note = p }))
                    .Concat(notes.Damages.Cast<TappableBase>().Select(p => new { Type = '4', Note = p }))
                    .Select(p => new
                    {
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(p.Note.Tick),
                        LaneIndex = p.Note.LaneIndex,
                        Width = p.Note.Width,
                        Type = p.Type
                    });

                foreach (var notesInBar in shortNotes.GroupBy(p => p.BarPosition.BarIndex))
                {
                    foreach (var notesInLane in notesInBar.GroupBy(p => p.LaneIndex))
                    {
                        var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(notesInBar.Key);
                        int barLength = barTick * sig.Numerator / sig.Denominator;

                        var offsetList = notesInLane.GroupBy(p => p.BarPosition.TickOffset).Select(p => p.ToList()).ToList();
                        var separatedNotes = Enumerable.Range(0, offsetList.Max(p => p.Count)).Select(p => offsetList.Where(q => q.Count >= p + 1).Select(q => q[p]));

                        foreach (var groupedNotes in separatedNotes)
                        {
                            var items = groupedNotes.Select(p => (p.BarPosition.TickOffset, p.Type + ToLaneWidthString(p.Width)));
                            writer.WriteLine("#{0:000}1{1}: {2}", notesInBar.Key, notesInLane.Key.ToString("x"), GenerateLineData(barLength, items));
                        }
                    }
                }

                var airs = notes.Airs.Select(p =>
                {
                    string type = "";
                    switch (p.HorizontalDirection)
                    {
                        case HorizontalAirDirection.Center:
                            type = p.VerticalDirection == VerticalAirDirection.Up ? "1" : "2";
                            break;

                        case HorizontalAirDirection.Left:
                            type = p.VerticalDirection == VerticalAirDirection.Up ? "3" : "5";
                            break;

                        case HorizontalAirDirection.Right:
                            type = p.VerticalDirection == VerticalAirDirection.Up ? "4" : "6";
                            break;
                    }

                    return new
                    {
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(p.Tick),
                        LaneIndex = p.LaneIndex,
                        Type = type,
                        Width = p.Width
                    };
                });

                foreach (var airsInBar in airs.GroupBy(p => p.BarPosition.BarIndex))
                {
                    foreach (var airsInLane in airsInBar.GroupBy(p => p.LaneIndex))
                    {
                        var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(airsInBar.Key);
                        int barLength = barTick * sig.Numerator / sig.Denominator;

                        var offsetList = airsInLane.GroupBy(p => p.BarPosition.TickOffset).Select(p => p.ToList());
                        var separatedNotes = Enumerable.Range(0, offsetList.Max(p => p.Count)).Select(p => offsetList.Where(q => q.Count >= p + 1).Select(q => q[p]));

                        foreach (var groupedNotes in separatedNotes)
                        {
                            var items = groupedNotes.Select(p => (p.BarPosition.TickOffset, p.Type + ToLaneWidthString(p.Width)));
                            writer.WriteLine("#{0:000}5{1}: {2}", airsInBar.Key, airsInLane.Key.ToString("x"), GenerateLineData(barLength, items));
                        }
                    }
                }

                var identifier = new IdentifierAllocationManager();

                var holds = book.Score.Notes.Holds
                    .OrderBy(p => p.StartTick)
                    .Select(p => new
                    {
                        Identifier = identifier.Allocate(p.StartTick, p.Duration),
                        StartTick = p.StartTick,
                        EndTick = p.StartTick + p.Duration,
                        Width = p.Width,
                        LaneIndex = p.LaneIndex
                    });

                foreach (var hold in holds)
                {
                    var startBarPosition = barIndexCalculator.GetBarPositionFromTick(hold.StartTick);
                    var endBarPosition = barIndexCalculator.GetBarPositionFromTick(hold.EndTick);
                    if (startBarPosition.BarIndex == endBarPosition.BarIndex)
                    {
                        var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(startBarPosition.BarIndex);
                        int barLength = barTick * sig.Numerator / sig.Denominator;

                        var items = new[]
                        {
                            (startBarPosition.TickOffset, "1" + ToLaneWidthString(hold.Width)),
                            (endBarPosition.TickOffset, "2" + ToLaneWidthString(hold.Width))
                        };
                        writer.WriteLine("#{0:000}2{1}{2}: {3}", startBarPosition.BarIndex, hold.LaneIndex.ToString("x"), hold.Identifier, GenerateLineData(barLength, items));
                    }
                    else
                    {
                        var startSig = barIndexCalculator.GetTimeSignatureFromBarIndex(startBarPosition.BarIndex);
                        int startBarLength = barTick * startSig.Numerator / startSig.Denominator;
                        var startItem = (startBarPosition.TickOffset, "1" + ToLaneWidthString(hold.Width));
                        writer.WriteLine("#{0:000}2{1}{2}: {3}", startBarPosition.BarIndex, hold.LaneIndex.ToString("x"), hold.Identifier, GenerateLineData(startBarLength, new[] { startItem }));

                        var endSig = barIndexCalculator.GetTimeSignatureFromBarIndex(endBarPosition.BarIndex);
                        int endBarLength = barTick * endSig.Numerator / endSig.Denominator;
                        var endItem = (endBarPosition.TickOffset, "2" + ToLaneWidthString(hold.Width));
                        writer.WriteLine("#{0:000}2{1}{2}: {3}", endBarPosition.BarIndex, hold.LaneIndex.ToString("x"), hold.Identifier, GenerateLineData(endBarLength, new[] { endItem }));
                    }
                }

                identifier.Clear();

                var slides = notes.Slides
                    .OrderBy(p => p.StartTick)
                    .Select(p => new
                    {
                        Identifier = identifier.Allocate(p.StartTick, p.GetDuration()),
                        Note = p
                    });

                foreach (var slide in slides)
                {
                    var start = new[] { new
                    {
                        TickOffset = 0,
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(slide.Note.StartTick),
                        LaneIndex = slide.Note.StartLaneIndex,
                        Width = slide.Note.StartWidth,
                        Type = "1"
                    } };
                    var steps = slide.Note.StepNotes.OrderBy(p => p.TickOffset).Select(p => new
                    {
                        TickOffset = p.TickOffset,
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(p.Tick),
                        LaneIndex = p.LaneIndex,
                        Width = p.Width,
                        Type = p.IsVisible ? "3" : "5"
                    }).Take(slide.Note.StepNotes.Count - 1);
                    var endNote = slide.Note.StepNotes.OrderBy(p => p.TickOffset).Last();
                    var end = new[] { new
                    {
                        TickOffset = endNote.TickOffset,
                        BarPosition= barIndexCalculator.GetBarPositionFromTick(endNote.Tick),
                        LaneIndex = endNote.LaneIndex,
                        Width = endNote.Width,
                        Type = "2"
                    } };
                    var slideNotes = start.Concat(steps).Concat(end);
                    foreach (var notesInBar in slideNotes.GroupBy(p => p.BarPosition.BarIndex))
                    {
                        foreach (var notesInLane in notesInBar.GroupBy(p => p.LaneIndex))
                        {
                            var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(notesInBar.Key);
                            int barLength = barTick * sig.Numerator / sig.Denominator;
                            var items = notesInLane.Select(p => (p.BarPosition.TickOffset, p.Type + ToLaneWidthString(p.Width)));
                            writer.WriteLine("#{0:000}3{1}{2}: {3}", notesInBar.Key, notesInLane.Key.ToString("x"), slide.Identifier, GenerateLineData(barLength, items));
                        }
                    }
                }

                identifier.Clear();

                var airActions = notes.AirActions
                    .OrderBy(p => p.StartTick)
                    .Select(p => new
                    {
                        Identifier = identifier.Allocate(p.StartTick, p.GetDuration()),
                        Note = p
                    });

                foreach (var airAction in airActions)
                {
                    var start = new[] { new
                    {
                        TickOffset = 0,
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(airAction.Note.StartTick),
                        Type = "1"
                    } };
                    var actions = airAction.Note.ActionNotes.OrderBy(p => p.Offset).Select(p => new
                    {
                        TickOffset = p.Offset,
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(p.ParentNote.StartTick + p.Offset),
                        Type = "3"
                    }).Take(airAction.Note.ActionNotes.Count - 1);
                    var endNote = airAction.Note.ActionNotes.OrderBy(p => p.Offset).Last();
                    var end = new[] { new
                    {
                        TickOffset = endNote.Offset,
                        BarPosition = barIndexCalculator.GetBarPositionFromTick(airAction.Note.StartTick + endNote.Offset),
                        Type = "2"
                    } };
                    var actionNotes = start.Concat(actions).Concat(end);
                    foreach (var airActionsInBar in actionNotes.GroupBy(p => p.BarPosition.BarIndex))
                    {
                        var sig = barIndexCalculator.GetTimeSignatureFromBarIndex(airActionsInBar.Key);
                        int barLength = barTick * sig.Numerator / sig.Denominator;
                        var items = airActionsInBar.Select(p => (p.BarPosition.TickOffset, p.Type + ToLaneWidthString(airAction.Note.ParentNote.Width)));
                        writer.WriteLine("#{0:000}4{1}{2}: {3}", airActionsInBar.Key, airAction.Note.ParentNote.LaneIndex.ToString("x"), airAction.Identifier, GenerateLineData(barLength, items));
                    }
                }
            }
        }

        protected string GenerateLineData(int barTick, IEnumerable<(int TickOffset, string Data)> items)
        {
            if (items.Any(p => p.TickOffset < 0 || p.TickOffset >= barTick)) throw new ArgumentException("Invalid TickOffset");
            if (items.Any(p => p.Data.Length != 2)) throw new ArgumentException("The data string length is not equal to 2.");

            int gcd = items.Select(p => p.TickOffset).Aggregate(barTick, (p, q) => GetGcd(p, q));
            var data = items.ToDictionary(p => p.TickOffset, p => p.Data);
            var sb = new StringBuilder();
            for (int i = 0; i * gcd < barTick; i++)
            {
                int tickOffset = i * gcd;
                if (data.ContainsKey(tickOffset)) sb.Append(data[tickOffset]);
                else sb.Append("00");
            }
            return sb.ToString();
        }

        public static int GetGcd(int a, int b)
        {
            if (a < b) return GetGcd(b, a);
            if (b == 0) return a;
            return GetGcd(b, a % b);
        }

        public static string ToLaneWidthString(int width)
        {
            return width == 16 ? "g" : width.ToString("x");
        }

        public static IEnumerable<string> EnumerateIdentifiers(int digits)
        {
            var num = Enumerable.Range(0, 10).Select(p => (char)('0' + p));
            var alpha = Enumerable.Range(0, 26).Select(p => (char)('A' + p));
            var seq = num.Concat(alpha).Select(p => p.ToString()).ToList();

            return EnumerateIdentifiers(digits, seq);
        }

        private static IEnumerable<string> EnumerateIdentifiers(int digits, List<string> seq)
        {
            if (digits < 1) throw new ArgumentOutOfRangeException("digits");
            if (digits == 1) return seq;
            return EnumerateIdentifiers(digits - 1, seq).SelectMany(p => seq.Select(q => p + q));
        }

        public class IdentifierAllocationManager
        {
            private int lastStartTick;
            private Stack<char> IdentifierStack;
            private ConcurrentPriorityQueue<Tuple<int, char>, int> UsedIdentifiers;

            public IdentifierAllocationManager()
            {
                Clear();
            }

            public void Clear()
            {
                lastStartTick = 0;
                IdentifierStack = new Stack<char>(EnumerateIdentifiers(1).Select(p => p.Single()).Reverse());
                UsedIdentifiers = new ConcurrentPriorityQueue<Tuple<int, char>, int>();
            }

            public char Allocate(int startTick, int duration)
            {
                if (startTick < lastStartTick) throw new InvalidOperationException("startTick must not be less than last called value.");
                while (UsedIdentifiers.Count > 0 && UsedIdentifiers.Peek().Item1 < startTick)
                {
                    IdentifierStack.Push(UsedIdentifiers.Dequeue().Item2);
                }
                char c = IdentifierStack.Pop();
                int endTick = startTick + duration;
                UsedIdentifiers.Enqueue(Tuple.Create(endTick, c), -endTick);
                lastStartTick = startTick;
                return c;
            }
        }
    }

    [Newtonsoft.Json.JsonObject(Newtonsoft.Json.MemberSerialization.OptIn)]
    public class SusArgs
    {
        [Newtonsoft.Json.JsonProperty]
        private string playLevel;
        [Newtonsoft.Json.JsonProperty]
        private Difficulty playDificulty;
        [Newtonsoft.Json.JsonProperty]
        private string extendedDifficulty;
        [Newtonsoft.Json.JsonProperty]
        private string songId;
        [Newtonsoft.Json.JsonProperty]
        private string soundFileName;
        [Newtonsoft.Json.JsonProperty]
        private decimal soundOffset;
        [Newtonsoft.Json.JsonProperty]
        private string jacketFilePath;
        [Newtonsoft.Json.JsonProperty]
        private bool hasPaddingBar;
        [Newtonsoft.Json.JsonProperty]
        private string additionalData;

        public string PlayLevel
        {
            get { return playLevel; }
            set { playLevel = value; }
        }

        public Difficulty PlayDifficulty
        {
            get { return playDificulty; }
            set { playDificulty = value; }
        }

        public string ExtendedDifficulty
        {
            get { return extendedDifficulty; }
            set { extendedDifficulty = value; }
        }

        public string SongId
        {
            get { return songId; }
            set { songId = value; }
        }

        public string SoundFileName
        {
            get { return soundFileName; }
            set { soundFileName = value; }
        }

        public decimal SoundOffset
        {
            get { return soundOffset; }
            set { soundOffset = value; }
        }

        public string JacketFilePath
        {
            get { return jacketFilePath; }
            set { jacketFilePath = value; }
        }

        public string AdditionalData
        {
            get => additionalData;
            set => additionalData = value;
        }

        public enum Difficulty
        {
            [Description("BASIC")]
            Basic,
            [Description("ADVANCED")]
            Advanced,
            [Description("EXPERT")]
            Expert,
            [Description("MASTER")]
            Master,
            [Description("WORLD'S END")]
            WorldsEnd
        }
    }
}
